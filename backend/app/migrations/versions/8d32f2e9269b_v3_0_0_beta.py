"""v3.0.0-beta

This adds the needed schema and data updates for issue #75: Reordering of survey items.

Revision ID: 8d32f2e9269b
Revises: 
Create Date: 2018-10-06 12:07:07.893786

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '8d32f2e9269b'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    op.add_column('dimension', sa.Column('position', sa.Integer(), nullable=False, server_default="0"))
    op.add_column('question', sa.Column('position', sa.Integer(), nullable=False, server_default="0"))
    op.alter_column('dimension', 'position', server_default=None)  # remove default, only needed for not null constraint
    op.alter_column('question', 'position', server_default=None)
    upgrade_data()


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('question', 'position')
    op.drop_column('dimension', 'position')
    # ### end Alembic commands ###


def upgrade_data():
    from model import db
    t_question = db.metadata.tables['question']
    t_dimension = db.metadata.tables['dimension']
    t_questionnaire = db.metadata.tables['questionnaire']

    connection = op.get_bind()

    # fetch all dimensions
    join = sa.join(t_questionnaire, t_dimension,
                   t_questionnaire.c.id == t_dimension.c.questionnaire_id)
    results = connection.execute(
        sa.select([
            t_questionnaire.c.id,
            t_dimension.c.id
        ]).select_from(join)
    )

    # set positions starting from 0 for every unique questionnaire
    dimension_position_counters = dict()
    for row in sorted(results, key=lambda r: r[1]):
        questionnaire_id = row[0]
        dimension_id = row[1]

        if questionnaire_id not in dimension_position_counters:
            dimension_position_counters[questionnaire_id] = 0
        dimension_position = dimension_position_counters[questionnaire_id]

        connection.execute(
            t_dimension.update().where(
                t_dimension.c.id == dimension_id
            ).values(
                position=dimension_position
            )
        )
        dimension_position_counters[questionnaire_id] = dimension_position + 1

    # fetch all questions
    join = sa.join(t_dimension, t_question,
                   t_dimension.c.id == t_question.c.dimension_id)
    results = connection.execute(
        sa.select([
            t_dimension.c.id,
            t_question.c.id
        ]).select_from(join)
    )

    # set positions starting from 0 for every unique dimension
    question_position_counters = dict()
    for row in sorted(results, key=lambda r: r[1]):
        dimension_id = row[0]
        question_id = row[1]

        if dimension_id not in question_position_counters:
            question_position_counters[dimension_id] = 0
        question_position = question_position_counters[dimension_id]

        connection.execute(
            t_question.update().where(
                t_question.c.id == question_id
            ).values(
                position=question_position
            )
        )
        question_position_counters[dimension_id] = question_position + 1
